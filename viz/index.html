<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Santhosh's Home</title>

    <!-- Framework CSS -->
    <link rel="stylesheet" href="css/blueprint/screen.css" type="text/css" media="screen, projection">
    <link rel="stylesheet" href="css/blueprint/print.css" type="text/css" media="print">
    <!--[if lt IE 8]><link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

    <!-- Import fancy-type plugin for the sample page. -->
    <link rel="stylesheet" href="css/blueprint/plugins/fancy-type/screen.css" type="text/css" media="screen, projection">
    <link rel="stylesheet" href="css/style.css" type="text/css">
    
    <script src="js/underscore-min.js" type="text/javascript"></script>
    <script src="js/jquery-1.7.1.min.js" type="text/javascript"></script>
    <script src="js/raphael.js" type="text/javascript"></script>
    <script src="js/popup.js" type="text/javascript"></script>
    <script src="js/utils.js" type="text/javascript"></script>
    <script src="js/cmap.js" type="text/javascript"></script>
    <script src="js/bwt.js" type="text/javascript"></script>
    <script src="js/view.js" type="text/javascript"></script>
    <script src="js/main.js" type="text/javascript"></script>

  </head>
  <body>
    <div class="container content">
      <div class="header">
        <h1>Santhosh's Home Page</h1>
        <hr>
      </div>
      <hr class="space">
      <div class="span-15 prepend-1 colborder">
        <h2>Elegant exact string match using BWT</h2>
        <blockquote>
        <p>This post is the first of a series where we describe some interesting algorithms used in our product <a href="http://avadis-ngs.com">Avadis NGS</a>. We have intentionally kept the usage of bioinformatics jargon minimum to benefit wider audience.</p>
        </blockquote>
        <p>This post describes an elegant and fast algorithm to perform exact string match. Why another string matching algorithm? To answer the question, we need to understand what the problem we are trying to solve is</p>
        <p>In short, the problem is to match billions of short strings (about 50-100 characters long) to a text which is 2 billion characters long. The 2 billion character string (referred to as the reference hereafter) is known ahead and is fixed (at least for a species). The shorter strings (called reads hereafter) are generated as a result of an experiment. The problem arises due to the way the <a href="http://en.wikipedia.org/wiki/DNA_sequencing">sequencing technology</a> works, which in its current form, breaks the DNA into small fragments and 'reads' them. The information about where the fragments came from is lost and hence the need to 'map' them back to the reference sequence</p>
        <p>We need an algorithm that allows repeatedly searching on a text as <i>fast</i> as possible. We are allowed to perform some preprocessing on the text once if that will help us achieve this goal. BWT search is one such algorithm. It requires a one-time preprocessing of the reference to build an index, after which the query time is of the order of the length of the query. (instead of the reference)</p>
        <p><a href="http://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform">Burrows Wheeler transform</a> is a reversible string transformation that has been widely used in data compression. However the application of BWT to perform string matching was discovered recently in this <a href="people.unipmn.it/manzini/papers/focs00draft.pdf">paper</a>. This technique is the topic of this post. Before we get to the searching application, a little background how BWT is constructed and some properties of BWT.</p>
        <p>BWT for a given text T is constructed as follows:</p>
        <ul>
          <li>Append a end of string character (say '$') to the text. This character should not be present in the text and is treated as the lexicographically largest character</li>
          <li>Collect all the cyclic permutations of the text and sort them.</li>
          <li>Arrange all the sorted strings one below the other. The last column forms the BWT</li>
        </ul>
        <p>The image below shows the BWT transform for BANANA$. In practice though, the above algorithm is very inefficient. There are smarter ways to get the BWT, but that is a topic for another post.</p>
        <img src="images/bwt.png" />
        <p>BWT has some nice properties which gives it its power:</p>
        <ul>
          <li>Reversible: The original text can be recovered easily from the BWT. TODO</li>
          <li>Rank preserving: TODO</li>
          <li>Compressibility: TODO</li>
        </ul>
        <h3>Search using BWT</h3>
        <p>Our data structure for search has three parts</p>
        <ol>
        <li>BWT of the string</li>
        <li>Suffix Array - </li>


        <div id="bwtparent">
          <div id="bwt"></div>
          <div id="controls">
            <button type="button" id="play">Play</button>
            <button type="button" id="step">Step</button>
          </div>
          <div id='status'>
            
          </div>
          <div id="inputs">
              <label for="inptext">Text:</label>
              <input type="text" name="inptext" id="inptext" value="abracadabra"/><br />
              <label for="query">Query:</label>
              <input type="text" name="query" id="query" value="ab"/><br />
              <button type="button" id="submit">Load</button>
          </div>
        </div>

      </div>
      <div class="span-7 last">
        <h3>Links</h3>
        <p>TODO</p>
        <h3>Misc</h3>
        <p>TODO</p>
      </div>
      <hr>
      <h3 class="alt footer">Footer</h3>
      <hr>
    </div>
  </body>
</html>

